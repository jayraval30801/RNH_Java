Access Specifier : 
		4 
				1) Public : Multiple Package 
				2) Default : Same Package
				3) Private : Outside Class not accessible
				4) Protected : Child class only can access

Multiple Classes (2 class)
	=> .Java Files
	=> .Class Files 
	
Main Method Multiple Possible
Operators: 
		1) Arithmetic + - / % * 
		2) Relational : > < >= <= 
		3) Conditional : && || !
		4) Turnery  : (? :)
		 (condition)?(statement):(falsestatement)
		5) Increment/Decre : ++ --  
		6) Bitwise :  & ^ | 
		
Oops: 
	Encapsulation : 
		Wrapping Of Data 
Constructor:
	
		CPP => ?  
		
			types :
				1) Default COn
				2) Paramete Con
			Properties : 
				Instance Create => Call 
	This Keyword : 
		Usages : 
			This keyword can be used to call Current Class Method 
			,Constructor, 
			Variable,
			return Method

Overloading : 
		Class Customer : customerId , Name , Balance => Multiple Customers
		
		=> Class => Bank => Searching 
				=> Array :  		
inheritence : 
		multilevel 
		single
		Hierarchical Inheri	

Which of the following is not a valid order for elements in a class?

A. Constructor, instance variables, method names
B. Instance variables, constructor, method names
C. Method names, instance variables, constructor
D. None of the above: all orders are valid.

========================================================================
package beach;
public class Sand 
{
	public Sand() 
	{
		System.out.print("a");
	}
public void Sand() 
	{
		System.out.print("b");
	}
public void run() 
{
	new Sand();
	Sand();
}
public static void main(String... args) 
{
	new Sand().run();
}
}

A. a
B. ab
C. aab
D. None of the above
======================================================================================
package registration;
public class NameCheck 
{
public static void main(String... data) 
{
	String john = "john";
	String jon = new String(john);
	System.out.print((john==jon)+" "+(john.equals(jon)));
}
}
A. true true
B. true false
C. false true
D. false false
==============================================================================================
package planning;
public class ThePlan
 {
public static void main(String[] input) 
{
	int plan = 1;
	plan = plan++ + --plan;
	if(plan==1) 
	{
		System.out.print("Plan A");
	} 
	else
	{ 
		if(plan==2) 
			System.out.print("Plan B");
	} 
	else
		 System.out.print("Plan C");
	}
}
A. Plan A
B. Plan B
C. Plan C
D. None of the above
==================================================================================
package dinosaur;
public class Park 
{
public final static void main(String... arguments) 
	{
	int pterodactyl = 6;
	long triceratops = 3;
	if(pterodactyl % 3 >= 1) // 6%3 => 0>=1
		triceratops++;
		triceratops--;
	System.out.print(triceratops);
	}
}
A. 2
B. 3
C. 4
D. The code does not compile
=========================================================================================	
package restaurant;
public class Pieces {
public static void main(String[] info) {
int flair = 15;
if(flair >= 15 && flair < 37)
 {
	System.out.print("Not enough");
 }
 if(flair==37) 
	{
		System.out.print("Just right");
	}
	 else
	 {	
		System.out.print("Too many");
	 }
}
}
A. Not enough
B. Just right
C. Too many
D. None of the above					
==========================================================================================
Which statement about case statements of a switch statement is not true?
A. A case value can be final.
B. A case statement must be terminated with a break statement.
C. A case value can be a literal expression.
D. A case value must match the data type of the switch variable, or be able to be
promoted to that type.
=============================================================================================
Given the following truth table, which operator for the boolean expressions x and y
corresponds to this relationship?
          x = true x = false
y = true   true     false
y = false  false    false
 A. --
 B. ++
 C. ||
 D. && => 
===========================================================================================
package jungle;
public class TheBigRace
 {
public static void main(String[] in) 
{
int tiger = 2;
short lion = 3;
long winner = lion+2*(tiger + lion);
System.out.print(winner);
}
}
A. 11
B. 13 => 
C. 25
D. None of the above
======================================================================================
int time = 11;
int day = 4;
String dinner = time > 10 ? day ? "Takeout" : "Salad" : "Leftovers";
A. Takeout
B. Salad
C. The code does not compile but would compile if parentheses were added.
D. None of the above =>
=====================================================================================
package recreation;
public class Dancing 
{
public static void main(String[] vars) 
{
int leaders = 10 * (2 + (1 + 2 / 5);
int followers = leaders * 2;
System.out.print((leaders + followers)< 10 ? "Too few" : "Too many");
}
}
A. Too few
B. Too many
C. The code does not compile.=>
D. The code compiles but throws a division by zero error at runtime
======================================================================================
package schedule;
public class PrintWeek {
public static final void main(String[] days) {
System.out.print(5 + 6 + "7" + 8 + 9);
}
}
A. 56789
B. 11789
C. 11717 =>
D. The code does not compile.
========================================================================
package transporter;
public class Rematerialize {
public static void main(String[] input) 
{
int dog = 11;
int cat = 3;
int partA = dog / cat;
int partB = dog % cat;
int newDog = partB + partA * cat;
System.out.print(newDog);
}
}
A. 9
B. 11 =>
C. 15
D. The code does not compile.
=======================================================================
Super Keyword 
Aggregation : 
	
		class => array 
			
				main method 
					child class obj = new child(a[],SIZE); => Para constructor => Logic Ascending Order
					Super(a[],SIZE) => Parent Constructor => Searching Logic	

===================================================================================
Abstraction : 
		Hiding of Data and Showing only Functionality 
		Hotel : 
				Menu : Dishes 
				Recipe :  Chef Manager 
abstract class : 
		class abstract keyword use 
		abstract methods and Non abstract methods 
		Variable can not be abstract 
interface  : 
		only abstract method 
========================================================================================
3. What is the output of the following application?
package stocks;
public class Bond
{
private static int price = 5;
public boolean sell() 
{
if(price<10) 
{
	price++;
	return true;
} 
else if(price>=10) 
{
	return false;
}
		
}
public static void main(String[] cash) {
new Bond().sell();
new Bond().sell();
new Bond().sell();
System.out.print(price);
}
}
A. 5
B. 6
C. 8
D. The code does not compile.		----
-================================================================================
What is the output of the following application?
package pet;
public class Puppy
 {
public static int wag = 5; // q1
public void Puppy(int wag) { // q2
this.wag = wag;
}
public static void main(String[] tail) {
System.out.print(new Puppy(2).wag); // q3
}
}
A. 2
B. It does not compile because of line q1.
C. It does not compile because of line q2.
D. It does not compile because of line q3. ---
======================================================================================
package ship;
public class Phone {
private int size;
public Phone(int size) {this.size=size;}
public static void sendHome(Phone p, int newSize) {
p = new Phone(newSize);
p.size = 4;
}
public static final void main(String... params) {
final Phone phone = new Phone(3);
sendHome(phone,7);
System.out.print(phone.size);
}
}
A. 3 --
B. 4
C. 7
D. The code does not compile
=========================================================================================
4. How many final modifiers would need to be removed for this application to compile?
package park;
public class Tree {
public final static long numberOfTrees;
public final double height;
static {}
{ final int initHeight = 2;
height = initHeight;
}
static {
numberOfTrees = 100;
height = 4;
}
}
A. None
B. One
C. Two
D. The code will not compile regardless of the number of final modifiers removed. --
====================================================================================
What is the output of the following application?
package jungle;
public class RainForest extends Forest 
{
public RainForest(long treeCount) 
{
	this.treeCount = treeCount+1;
}
public static void main(String[] birds)
{
	System.out.print(new RainForest(5).treeCount);
}
}
class Forest 
{
public long treeCount;
public Forest(long treeCount) 
{
	this.treeCount = treeCount+2;
}
}
A. 5
B. 6
C. 8
D. The code does not compile. ----
======================================================================================
public class ChooseWisely {
public ChooseWisely() { super(); }
public int choose(int choice) { return 5; }
public int choose(short choice) { return 2; } // -32677 to 32678
public int choose(long choice) { return 11; }
public static void main(String[] path) {
System.out.print(new ChooseWisely().choose((byte)2+1));
}
}
A. 5 --
B. 2
C. 11
D. The code does not compile
======================================================================================
abstraction :
interface : 
		multiple inheritence : multiple parents and only one child 
		only abtract method
		int a=12; => compiler => public static 	final int a = 12;	
		void print(); => compiler => public abstract void print();
		
child class =>parent class => extends 
child class => parent interface => implements 
child interface => parent interface => extends 
child interface => parent class => not possible

